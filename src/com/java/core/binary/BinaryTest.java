package com.java.core.binary;

import org.junit.Test;

import java.util.Arrays;

/**
 * @description: 用于演示 四种进制的类
 * 1.二进制是逢2进位的进位制，0、1是基本算符。
 * 2.现代的电子计算机技术全部采用的是二进制，因为它只使用0、1两个数字符号，
 * 非常简单方便，易于用电子方式实现。计算机内部处理的信息，都是采用二进制数来表示的。
 * 二进制（Binary）数用0和1两个数字及其组合来表示任何数。
 * 进位规则是"逢2进1"，数字1在不同的位上代表不同的值，按从右至左的次序，这个值以二倍递增。
 * @author Mr.luo
 * @date 2021/12/2 12:10 上午
 * @version 1.0
 */
public class BinaryTest {


    public static void main(String[] args) {
        //n1 二进制
        int n1 = 0b110001100;
        // n2 10 进制
        int n2 = 1010;
        // n3 8
        int n3 = 02456;
        //n4 16 进制
        int n4 = 0xA45;
        System.out.println("n1=" + n1);
        System.out.println("n2=" + n2);
        System.out.println("n3=" + n3);
        System.out.println("n4=" + n4);
        System.out.println(0x23A);

        System.out.println(-1 >> 5);

    }

    /**
     * @description: 位运算符 & , | , ^ , ~
     * 本节需要使用到的知识点:
     * 网上对原码，反码，补码的解释过于复杂，我这里精简几句话∶（背下来）对于有符号的而言∶
     * 1.二进制的最高位是符号位∶0表示正数，1表示负数（老韩口诀∶0->01->-）
     * 2.正数的原码，反码，补码都一样（三码合一）
     * 3.负数的反码=它的原码符号位不变，其它位取反（0->1，1->0）
     * 4.负数的补码=它的反码+1，负数的反码 = 负数的补码-1
     * 5.O的反码，补码都是0
     * 6. java没有无符号数，换言之，java中的数都是有符号的
     * 7.在计算机运算的时候，都是以补码的方式来运算的. 重点
     * 8.当我们看运算结果的时候，要看他的原码（重点）
     * @author Mr.luo
     * @date: 2021/12/3 10:16 下午
     */
    @Test
    public void bitOperationTwo(){

        // 按位与 & 规则：两位全为1，结果为1，否则为0
        // 2的补码：00000000 00000000 00000000 00000010
        // 3的补码：00000000 00000000 00000000 00000011
        // &的结果：00000000 00000000 00000000 00000010 == 2
        System.out.println(2&3);

        // 负数 按位取反 ~ 运算规则： 0变1 1变0
        // -5的原码：10000000 00000000 00000000 00000101
        // -5的反码：11111111 11111111 11111111 11111010 //符号位不变 其他位取反
        // 由于 在计算机运算的时候，都是以补码的方式来运算的 负数补码= 它的反码 + 1
        // -5的补码：11111111 11111111 11111111 11111011
        //~-5的结果：00000000 00000000 00000000 00000100 得到运算后的补码 由于是正数 补码就是原码所以结果为 4
        System.out.println(~-5);

        // 正数按位取反 ：运算规则： 0变1 1变0
        // 正2的原码为: 00000000 00000000 00000000 00000010
        // 由于 在计算机运算的时候，都是以补码的方式来运算的 特点
        // 获取2的补码：00000000 00000000 00000000 00000010  （正数的原码，反码，补码都一样）
        // 取～2操作得：11111111 11111111 11111111 11111101 运算后的补码 当前是：负数的补码
        // 由于现在是负数 要获取到它的反码 ：负数的反码 = 负数的补码-1
        // 负数的反码   11111111 11111111 11111111 11111100
        // 按负数转原码的规则：它的原码符号位不变，其它位取反（0->1，1->0）
        // 转换成原码： 10000000 00000000 00000000 00000011 结果为 -3
        System.out.println(~2);

        // 按位或 ｜ 运算规则： 两位有一个为1，结果为1，否则为0
        // 获取2的补码：00000000 00000000 00000000 00000010
        // 获取3的补码：00000000 00000000 00000000 00000011
        // 进行|运算后：00000000 00000000 00000000 00000011 == 3
        System.out.println(2|3);



        // 按位与 & 运算规则：两位全为1 则为1 ，否则为0
        // 13的补码：00000000 00000000 00000000 00001101
        // 7 的补码：00000000 00000000 00000000 00000111
        // & 的结果：00000000 00000000 00000000 00000101 == 5
        System.out.println(13&7);

        // 按位或 ｜ 运算规则： 两位有一个为1，结果为1，否则为0
        // 获取5的补码：00000000 00000000 00000000 00000101
        // 获取4的补码：00000000 00000000 00000000 00000100
        // 进行|运算后：00000000 00000000 00000000 00000101 == 5
        System.out.println(5|4);

        // 按位异或 ^ 运算规则：两位一个为0，一个为1，结果为1，否则为0
        // -3的原码：10000000 00000000 00000000 00000011
        // -3的补码：11111111 11111111 11111111 11111101
        //  3的补码：00000000 00000000 00000000 00000011
        // 按位异或：11111111 11111111 11111111 11111110 的补码
        // 由于是负数：负数的反码 = 负数的补码-1
        //         11111111 11111111 11111111 11111101
        // 得到原码：10000000 00000000 00000000 00000010  == -2
        System.out.println(-3^3);
    }

    /**
     * @description: 位运算 >> << >>>
     * 算术右移 >>：低位溢出,符号位不变,并用符号位补溢出的高位
     * 算术左移 <<: 符号位不变,低位补 0
     * 逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0
     * @author luo
     * @date: 2021/12/2 11:05 下午
     */
    @Test
    public void bitOperation(){

        // 推导 算数右移 1 向算数右移两位
        // 2的补码：00000000 00000000 00000000 00000010
        //         00000000 00000000 00000000 00000000 == 0
        // 本质就是 2/2
        int a=1>>2;

        // -1的原码：10000000 00000000 00000000 00000001
        // -1的补码：负数的补码 = 负数的反码+1
        // -1的反码：11111111 11111111 11111111 11111110
        // -1的补码：11111111 11111111 11111111 11111111
        // -1>>2后：11111111 11111111 11111111 11111111 补码
        // 负数的反码= 负数的补码 - 1
        // 得到结果：11111111 11111111 11111111 11111110 反码
        // 原码结果：10000000 00000000 00000000 00000001 // -1
        int b=-1>>2; // 算术右移

        // 符号位不变,低位补 0
        // 1的补码：00000000 00000000 00000000 00000001
        // 左移2位：00000000 00000000 00000000 00000100 == 4
        // 本质就是 1 * 2 * 2
        int c=1<<2;

        // 符号位不变,低位补 0
        // -1的原码：10000000 00000000 0000000 00000001
        // -1的补码：11111111 11111111 11111111 11111111
        // 左 移2位：11111111 11111111 11111111 11111100 补码
        // 负数的反码= 负数的补码 - 1
        // 得到反码：11111111 11111111 11111111 11111011
        // 得到原码：10000000 00000000 00000000 00000100 == -4
        int d=-1<<2;

        // 低位溢出，高位补 0
        // 得到3的补码：00000000 00000000 00000000 00000011
        // 无符号右移2：00000000 00000000 00000000 00000000 == 0
        int e=3>>>2;//无符号右移

    }
}

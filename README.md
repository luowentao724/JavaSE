# 该项目主要用于 巩固 Java SE 基础相关知识

### [二进制，八进制，十进制，十六进制，位运算](https://github.com/luowentao724/JavaSE/tree/master/src/com/java/core/base/BinaryTest.java)

## 🌕 Java 编程基础（45 天）
### 知识

- 环境搭建 (TODO windows 和 mac 两种文档 耗时 2 小时)
- IDEA 开发工具 (TODO 输出四篇文档 耗时工作 8 小时)
    - 新建项目 
    - 运行调试
    - 界面配置
    - 插件管理
- **Java 基础语法**
    - 数据类型  (文档一篇 4 小时)
    - 流程控制  (文档一篇 8 小时)
- 数组
- **面向对象** (文档一篇 8 小时)
    - 方法
    - 重载 
    - 封装
    - 继承
    - 多态
- 抽象类 (文档一篇 4 小时)
- 接口 (文档一篇 4 小时)
- 枚举 (文档一篇 4 小时)
- 常用类 (文档两篇 8 小时)
    - String 
    - 日期时间
- 集合类 (文档一篇 16 小时)
- 泛型 (文档一篇 16 小时)
- 注解 (文档一篇 16 小时)
- 异常处理 (文档一篇 16 小时)
- 多线程 (文档一篇 16 小时)
- IO 流 (文档一篇 16 小时)
- 反射 (文档一篇 16 小时)

## 面向对象

#### 什么是方法？ 
 * 用面向对象的思想表达就是：某一类对象 存在的行为 叫做方法
 * 例如：人除了有年龄，名称等这些属性还有吃，跑步，学习，做题等这些行为
 * 方法的作用：提高代码的复用性，体现面向对象三大特性 的 封装
##### 方法的定义
   * 成员方法：访问修饰符  返回值类型  方法名 （参数列表 ...）
     ```
      // 这是一个 无返回值的 公开方法，需要传入一个 String 类型参数
      public void testMethod(String str) {
        // 方法体
      }
     
     // 这是一个 有返回值的 私有方法，需要传入一个 String 类型参数
      private String testMethod(String str) {
        // 方法体
        return "我是返回值"；
      }
     ```
    
     * 访问修饰符：public ，protected, 默认, private]
     * 返回值类型：可以是基本类型和引用类型 ，void 表示没有返回值，如果方法要求有返回值则必须返回，否则会报错
     * 方法名：遵循驼峰命名法，最好见名知义，表达出该功能的意思即可, 比如 得到两个数的和 getSum, 开发中按照规范
     * 参数列表：表示成员方法输入 cal(int n) ， getSum(int num1, int num2)

#### 什么是重载（OverLoad）？
  重载主要体现在方法上。
  在同一个类重有两个方法它们的方法名相同，参数类型不一致 就是重载。
  ```
  public class OverLoadClass {
  
    public void testOverLoad(String str ,int num){
    
    }
    
    public void testOverLoad(String str ,String str2){
    
    }
  }
  
  ```
##### 重载的好处？
  * 减轻了起名的麻烦
  * 减轻了记名的麻烦

##### 可变参数
基本概念：java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。 
        就可以通过可变参数实现
```
  public void changeParam(int ...nums){
    for(int i=0;i<nums.length;i++){
      System.out.println(nums[i]);
    }
  }
  // 调用时 changeParam(0)  changeParam(2,4,6) 这样都可以
```
* 可变参数的实参可以是多个和任意多个
* 可变参数的实惨可以为数组
* 可变参数的本质就是数组
* 可变参数可以和普通类型参数放在一起，但可变参数必须放在最后
* 一个形参列表中只能有一个可变参数

##### 什么是变量作用域？
    总结 ：变量在 Java程序的生效范围。
* Java 编程中，主要的变量就是 属性（成员变量）和局部变量
* 局部变量一般是指在成员方法中定义的变量。
* Java中作用域的分类
  * 全局变量也就是属性，作用于整个类体 ，例如 Cat ，eat 等方法使用属性
  * 局部变量：也就是除属性之外的其他变量，作用域为定义它的代码块中。
* 全局变量可以不赋值直接使用，因为有默认值 ，局部变量必须赋值后才能使用，因为没有默认值

```
public class VarScope {
     
     // 全局变量 可以赋值
    private String num = 10;
    
    //也可以不赋值 ，默认为 false
    Boolean flag;
    
    // 这里的 num 也属于局部变量
    public void test(Integer num){
        String sc = "局部变量";
    }
}
```
 
##### 构造方法 / 构造器
总结：创建类实例的时候默认执行的方法，完成对新对象的初始化，可以用于给成员变量赋值。方法名必须和类名相同。可以重载。
* 构造器的修饰符可以默认，也可以是public protected private
* 构造器没有返回值
* 方法名和类名字 必须一样
* 参数列表 和 成员方法一样的规则
* 构造器的调用，由系统完成
* 如果没有为类定义构造器，则编译器会自动给该类生成一个默认的无参构造器，定义了，则不会有默认构造器

```
public class Person{
    
    String name;
    
    int age;
    // 这就是构造方法 ， this 关键字 用于指定当前对象的属性
    Person(String name,int age){
        this.name = name;
        this.age = age;
    }
    
}
```

##### 什么是访问修饰符，都有什么作用？
Java 中提供四种访问控制修饰符号，用于控制方法和属性（范围）：
* 公开级别：public 修饰，对外公开
* 受保护级别：用 protected 修饰，对子类和同一个包中的类公开
* 默认级别：没有修饰符号，向同一个包中的类公开
* 私有级别：用private 修饰，只有类本身可以访问，不对外公开。

|访问级别 | 访问控制修饰符 | 同类 | 同包 | 子类 | 不同包 |
| :-----| ----: | :----: |:----: |:----: |:----: |
| 公开 | public | ✅ | ✅ | ✅ | ✅ |
| 受保护 | protected | ✅ | ✅ | ✅ | ❌ |
| 默认 | default | ✅ | ✅ | ❌ | ❌ |
| 私有级别 | private | ✅ | ❌ | ❌ | ❌ |

* 修饰符可以用用来修饰类中的属性，成员方法以及类
* 只有默认的和public 才能修饰类，并且遵循上述访问权限的特点
* 成员方法的访问规则和属性一样

#### 封装
总结：封装就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据惊进行操作。

##### 封装的步骤
* 将属性私有化 private
* 提供一个公共方法（public） set方法，用于对属性判断与赋值
* 提供一个公共的 get 方法，用于获取该属性的值

#### 继承
总结：继承就是将一些类的公共属性，方法提取出来，作为父类，不同的地方由各个子类去实现。extents 关键字   
例如：人属于一个类，它有公共的属性 身高，体重，年龄等，学生也是一个类，但学生是属于人的一种，
它除了有刚才人的属性外还有其他 班级，学校等属性，
此时咱们就可以用 学生类 去继承 人类，学生类就自动拥有人这个父类的所有属性和方法类。

作用：继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中 抽象出父类,在父类中定义这些相同的属性和方法，
所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来 声明继承父类即可。画出继承的示意图

![img.png](image/img.png)

```
// 继承的基本语法
class 子类 extents 父类 {
    // 子类会自动拥有父类定义的属性和方法
    // 父类又叫超类，基类
    // 子类又叫派生类
}
```
##### 继承的细节总结
1) 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问 
2) 子类必须调用父类的构造器， 完成父类的初始化 
3) 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无 参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译 不会通过
4) 如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表) 
5) super 在使用时，必须放在构造器第一行(super 只能在构造器中使用) 
6) super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器 
7) java 所有类都是 Object 类的子类, Object 是所有类的基类. 
8) 父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类) 
9) 子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。 思考：如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】 
10) 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系

##### 继承的本质分析
用一个案例来分析当子类继承父类，创建子类对象时，内存中到底发生了什么？（建立查找关系）

```
package com.java.core.inherit;

/**
 * @author Mr.luo
 * @version 1.0
 * @description: 继承的本质分析
 * @date 2021/12/11 8:47 下午
 */
public class ExtendsTheory {
    public static void main(String[] args) {
        Son son = new Son();
        //内存的布局
        // ?-> 这时请大家注意，要按照查找关系来返回信息
        // (1) 首先看子类是否有该属性
        // (2) 如果子类有这个属性，并且可以访问，则返回信息
        // (3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)
        // (4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object...
        // 返回就是大头儿子
        System.out.println(son.name);
        // 返回的就是 39
        System.out.println(son.getAge());
        // 返回的就是旅游
        System.out.println(son.hobby);
    }
}

/**
 * @author Mr.luo
 * @version 1.0
 * @description: 爷类
 * @date 2021/12/11 9:12 下午
 */
class GrandPa {
    String name = "大头爷爷";
    String hobby = "旅游";
}

/**
 * @author Mr.luo
 * @version 1.0
 * @description: 父类
 * @date 2021/12/11 9:14 下午
 */
class Father extends GrandPa {
    String name = "大头爸爸";
    private int age = 39;

    public int getAge() {
        return age;
    }
}

/**
 * @author Mr.luo
 * @version 1.0
 * @description: 子类
 * @date 2021/12/11 9:15 下午
 */
class Son extends Father {
    String name = "大头儿子";
}
```
上段代码 Son son = new Son()的内存分析图：

![img.png](image/extendsTheory.png)

##### super 关键字
总结：super关键字代表父类的引用 ，用于访问父类的属性，方法，构造器。  
访问父类的属性不能访问 private 修饰的。
访问父类的方法不能访问 private 修饰的。
访问父类的构造器，有且只能写在子类构造器的第一行。  
> this 关键字 和 super 关键字的区别：

|No | 区别点 | this | super |
| :-----| :-----: | :----: |:----: |
| 1 | 访问属性 | 访问本类的属性，如果本类没有则会从父类查找 | 从父类开始查找属性 |
| 2 | 调用方法 | 访问本类的方法，如果本类没有方法会从父类中查找 | 从父类开始查找方法 |
| 3 | 调用构造器 | 调用本类构造器必须放在构造器首行 | 调用父类构造器必须放在子类构造器第一行|
| 4 | 特殊 | 表示当前对象 | 子类访问父类对象 |

##### 方法的重写[override]
简单的说∶方法覆盖（重写）就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，
那么我们就说子类的这个方法覆盖了父类的方法  

注意事项和使用细节  
* 子类方法的形参列表 和 方法名称 要和父类方法的 形参列表和方法名称一致 
* 子类方法的返回类型 必须和父类方法的返回类型一致 ，或者是父类返回类型的子类
* 子类方法不能缩小父类方法的返回权限 public -> protected -> default -> private
```
// 父类方法
public Object overrideTest(){
}

// 子类重写类父类的overrideTest 
public String overrideTest(){
}

```
##### 重写和重载的区别
| 名称| 发生范围| 方法名| 形参列表| 返回值类型| 修饰符|   
| :-----| :-----: | :----: |:----: |:----: |:----: |
|重载 | 同一个类| 必须一致 | 必须不一致| 无要求 | 无要求|   
|重写 | 父子类| 必须一致 | 必须一致| 必须和父类方法的返回类型一致 ，或者是父类返回类型的子类| 子类方法的访问权限大于等于父类方法|   

#### 什么是多态？
方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。  
多态的具体体现：
1. 方法的多态，主要体现在重载 和 重写
2. 对象的多态
   1. 一个对象的编译类型和运行类型可以不一致
   2. 编译类型在定义对象时就确定了，不能改变
   3. 运行类型是可以变化的
   4. 编译类型看定义是 = 号的左边，运行类型看 = 的右边

##### 多态的注意事项与细节讨论
多态的前提：两个对象（类）必须存在继承关系   

多态的向上转型
* 本质：父类引用指向子类对象
* 语法：父类 引用名 = new 子类()
* 特点：编译类型看左边，运行类型看右边。可以调用父类中所有成员(需遵循访问权限)，不能调用子类特有成员，最终运行效果看子类的实现。

多态的向下转型
* 语法：子类 子类引用 = (子类)父类引用;
* 只能强转父类引用，不能强转父类对象
* 当前父类对象的引用，必须指向当前目标类型的对象。
* 当向下转型时，可以调用子类中所有成员。

Java 动态绑定机制
* 调用对象方法时，该对象会自动绑定该对象运行时对象的**内存地址/运行类型**绑定
* 当调用对象属性时，没有动态绑定机制，在那里调就在那里用

#### static 代码块
代码化块又称为初始化块，属于类中的成员【即 是类的一部分】，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。  
但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。
```
    // 基本语法
    [修饰符]{
     代码
    }
    // 修饰符可选，要写的话，也只能写static
    // 代码块分为两类，使用 static 修饰的叫静态代码块，没有static修饰的，叫普通代码块
    // 逻辑语句可以为任何逻辑语句（输入，输出，方法调用，循环，判断等）
    // ;号可以写上，也可以省略
```

##### 代码块使用注意事项 和 细节
* static 代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象就执行。
* 类什么时候被加载
  * 创建对象实例时（new 时）
  * 创建子类对象实例，父类也会被加载
  * 使用类的静态成员时（静态属性，静态方法）
* 普通代码块，在创建对象实例是，会被隐式的调用。被创建一次就调用一次，如果是使用类静态成员是，普通代码块并不会被执行。

#### final 关键字
final中文意思： 最后的，最终的
final 可以修饰类，属性，方法和局部变量
在某些情况下，程序员可能有一下需求，就会使用到final：
* 当不希望类被继承时，可以用final修饰
* 当不希望父类的某个方法被子类重写(override)时,可以用 final 关键字修饰。
* 当不希望类的某个属性值被修改，可以用final修饰
* 当不希望某个局部变量被修改，可以使用final 修饰

##### final 使用注意事项和细节讨论
* final 修饰的属性又叫常量，一般用 XX_XX_XX 来命名
* final 修饰的属性在定义时，必须赋初始值，并且以后不能再修改，赋值可以在如下位置之一：
  * 定义时
  * 在构造器中
  * 在代码块中
* 如果final 修饰的属性是静态的，则初始化的位置只能是
  * 定义时 和 静态代码块
* final 类不能被继承，但是可以实例化对象
* 如果类不是final 类，但是含有final 方法，则该方法虽然不能重写，但是可以被继承

#### 抽象类
* 用abstract 关键字来修饰一个类时，这个类就叫抽象类
```
 // 访问修饰符 abstract 类名 {}
 public abstract AbstractDemo{}
```
* 用abstract 关键字来修饰一个方法是，这个方法就是抽象方法
```
// 访问修饰符 abstract 返回类型 方法名(参数列表); 没有方法体
public abstract void abstractMothod(String test);
```
* 抽象类的价值更多的作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()

##### 抽象类使用的注意事项和细节讨论
* 抽象类不能被实例化
* 抽象类不一定要包含 abstract 方法。也就是说，抽象类可以没有abstract 方法
* 一旦类包含类 abstract 方法，则这个类必须声明为abstract 类
* abstract 只能修饰类和方法，不能修饰属性和其他的。

##### 抽象类最佳实践 - 模版设计模式
抽象类体现的就是一种模版模式的设计，抽象类作为多个子类的通用模版，子类在抽象类的基础上进行扩展，改造，但子类总体上会保留抽象类的行为方式  

模版设计模式能解决的问题
* 当功能内部的一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类实现。
* 编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模版模式

#### 接口
接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体的情况把这些方法写出来。
```
interface Demo{
 // 属性
 // 抽象方法
}
class 类命 implements 接口 {
  //必须实现的接口的抽象方法
}
```
小结：接口是更加抽象的抽象类，抽象类里的方法可以有方法体，接口里所有的方法都没有方法体（1.7)。接口体现了程序设计的多台和高内聚低耦合的设计思想。  
特别说明：Jdk8 后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现

##### 注意事项与细节
* 接口不能被实例化
* 接口中所有的方法是public方法，接口中抽象方法，可以不用 abstract 修饰
* 一个普通了实现接口，就必须将该接口的所有方法都实现
* 抽象类实现接口，可以不用实现接口方法

##### 接口的多态特性
* 多态参数
* 多态数组
* 接口存在多态传递现象

#### 内部类
一个类的内部又完整的嵌套了另一个类结构。被签到的类称为内部类（inner class），
嵌套其他类的类称为外部类（outer class）。是我们类的第五大成员 （属性，方法，构造器，代码块，内部类）
内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间包含关系，注意： 内部类是学习的难点，同时也是重点。
```
class Outer {
    class Inner{
    
    }
}
```
##### 内部类的分类
定义在外部类局部位置上（比如方法内）：
* 局部内部类（有类名）
* 匿名内部类（没有类名，重点）
定义在外部类的成员位置上：
* 成员内部类（没有static修饰）
* 静态内部类（使用static修饰）

##### 局部内部类的使用
说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名。
* 可以直接访问外部类的所有成员，包含私有的
* 不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final 修饰，因为局部变量也可以使用final
* 作用域：仅仅在定义它的方法或代码块中。
* 局部内部类 --- 访问 ----> 外部类的成员[访问方式：直接访问]
* 外部类 --- 访问 -----> 局部内部类的成员
  * 访问方式：创建对象，再访问（注意：必须在作用域内）

记住：
* 局部内部类定义在方法中/代码块
* 作用域在方法提或代码块中
* 本质仍然是一个类

* 外部其他类 --- 不能访问 ----> 局部内部类（因为 局部内部类地位是一个局部变量）
* 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问

##### 匿名内部类的使用（重要）
* 本质是类 
* 内部类
* 该类没有名字
* 同时还是一个对象
说明匿名内部类是定一个在外部类的局部位置，比如方法中，并且没有类名
1. 匿名内部类的基本语法

```
new 类或接口(参数列表){
类体
}
```

##### 成员内部类的使用
说明：成员内部类是定义在外部类的成员位置，并且没有static修饰。
1. 可以直接访问外部类的所有成员，包含私有
2. 可以添加任意访问修饰符(public ,protected,默认，private)，因为它的地位就是一个成员
3. 作用域和外部类的其他成员一样，为整个类体
4. 成员内部类 --- 访问 ----> 外部类成员 直接访问
5. 外部类 --- 访问 -----> 成员内部类 访问方式：创建对象，再访问
6. 外部其他类 --- 访问 ----> 成员内部类
7. 如果外部类和内部类的成员重名时，内部类访问的化，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问

##### 静态内部类的使用
说明：静态内部类是定义在外部类的成员位置，并且有static修饰
1. 可以直接放外部类的所有静态成员，包含私有的，但不能直接访问非静态成员
2. 可以添加任意访问修饰符（public，protected，默认，private）因为它的地位就是一个成员
3. 作用域：同其他的成员，为整个类体
4. 静态内部类 --- 访问 ----> (比如：静态属性)[访问方式：直接访问所有静态成员]
5. 外部类 --- 访问 -----> 静态内部类访问方式：创建对象，再访问
6. 外部其他类 --- 访问 ----> 静态内部类
7. 如果外部类和静态内部类的成员重名是，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问

### 🌖 Java 8（3 天）
#### 知识
- Stream API
- Lambda 表达式
- 新日期时间 API
- 接口默认方法



